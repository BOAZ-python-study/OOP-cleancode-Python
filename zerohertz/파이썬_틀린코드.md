> Index

- [소개, 코드 포매팅과 도구](#소개-코드-포매팅과-도구)
- [파이썬스러운 (Pythonic) 코드](#파이썬스러운-pythonic-코드)
- [좋은 코드의 일반적인 특징](#좋은-코드의-일반적인-특징)
- [SOLID 원칙](#solid-원칙)
- [데코레이터를 사용한 코드 개선](#데코레이터를-사용한-코드-개선)
- [디스크립터로 더 멋진 객체 만들기](#디스크립터로-더-멋진-객체-만들기)
- [제네레이터 사용하기](#제네레이터-사용하기)
- [단위 테스트와 리팩토링](#단위-테스트와-리팩토링)
- [일반적인 디자인 패턴](#일반적인-디자인-패턴)
- [클린 아키텍쳐](#클린-아키텍쳐)

---

<!-- 5주차 -->

# 소개, 코드 포매팅과 도구

+ [클린코드](https://hypers84.tistory.com/2460)란?
  1. 가독성: 이해하기 쉬운 용어 사용, 코드 작성 시 들여쓰기 기능 사용
  2. 단위성: 한 번에 한 가지 처리만 수행, 클래스 / 메서드 / 함수를 최소 단위로 분리
  3. 의존성: 영향도를 최소화, 코드의 변경이 다른 부분에 영향이 없게 작성
  4. 중복성: 중복된 코드를 제거, 공통된 코드를 사용
  5. 추상화: 클래스 / 메서드 / 함수에 대해 동일한 수준의 추상화 구현, 상세 내용은 하위 클래스 / 메서드 / 함수에서 구현
+ 코드 포매팅 == 클린코드?
  + 코드를 포매팅 하고 구조화하는 것은 클린코드의 최소요건
  + 코드 포매팅이 클린코드라는 명제는 **틀린 명제**
+ 코드를 잘 설명하는 방법
  1. 주석
     + Pros: 외부 라이브러리에 오류가 있는 경우
     + Cons: 코드에 포함되고 코드와 함께 업데이트가 되지 않을 수 있음
  2. 함수의 이름과 파라미터의 이름
  3. Docstring
     + `__doc__`을 통해 호출 가능
     + 설명 없이 코드만 보아도 직관적으로 이해가 되는 코드가 좋음
  4. Annotation
     + `__annotations__`를 통해 확인 가능
     + 동적 타입 언어의 특성은 바뀌지 않음

```python
>>> zerohertzLib.vision.grid.__doc__
'여러 image를 입력받아 한 정방형 image로 병합\n\n    Args:\n        imgs (``List[NDArray[np.uint8]]``): 입력 image\n        size: (``Optional[int]``): 출력 image의 크기\n        color: (``Optional[Tuple[int]]``): Padding의 색\n        file_name: (``Optional[str]``): 저장될 file의 이름\n\n    Returns:\n        ``None``: 현재 directory에 바로 image 저장\n\n    Examples:\n        >>> imgs = [cv2.resize(img, (random.randrange(300, 1000), random.randrange(300, 1000))) for _ in range(8)]\n        >>> imgs[2] = cv2.cvtColor(imgs[2], cv2.COLOR_BGR2GRAY)\n        >>> imgs[3] = cv2.cvtColor(imgs[3], cv2.COLOR_BGR2BGRA)\n        >>> zz.vision.grid(imgs)\n        >>> zz.vision.grid(imgs, color=(0, 255, 0))\n        >>> zz.vision.grid(imgs, color=(0, 0, 0, 0))\n\n        .. image:: _static/examples/dynamic/vision.grid.png\n            :align: center\n            :width: 600px\n    '
>>> zerohertzLib.vision.grid.__annotations__
{'imgs': typing.List[numpy.ndarray[typing.Any, numpy.dtype[numpy.uint8]]], 'size': typing.Union[int, NoneType], 'color': typing.Union[typing.Tuple[int], NoneType], 'file_name': typing.Union[str, NoneType], 'return': None}
```

<!-- 5주차 -->

---

<!-- 6주차 -->

# 파이썬스러운 (Pythonic) 코드

+ 인덱스와 슬라이스
  + 인덱싱: 음수를 사용한 배열의 끝 부터의 접근
  + 슬라이싱: 특정 구간의 요소 (`[::2]`)
+ 컨텍스트 관리자
  + 리소스 관리: `with`를 통한 리소스 해제
  + 구현: `__enter__`와 `__exit__` 메서드 사용 (또는 `contextlib.ContextDecorator`)
+ 프로퍼티, 속성과 객체 메서드의 다른 타입들
  + `getter`: `@property`
  + `setter`: `@${PROPERTY_NAME}.setter`
  + 명시적인 (암묵적인) private 정의는 가능하지만 파이썬의 모든 프로퍼티와 함수는 public
+ 이터러블 객체
  + 이터러블: `__iter__`
  + 이터레이터: `__next__`
+ 컨테이너 객체
  + `in` 연산 수행을 위해 `__contains__` 메서드를 구현
+ 객체의 동적 속성
  + `__getattr__` 메서드 정의를 통해 인스턴스의 멤버변수를 알아낼 수 있음
  + 정의 시 파이썬 내장 함수 `getattr`에도 영향
+ 호출형 객체
  + `__call__`을 통해 인스턴스를 함수와 같이 활용 가능
+ 파이썬의 지양점
  + 변경 가능한 파라미터 기본 값 (`[1, 2, 3]`, ...)
  + `str`은 선언과 동시에 이루어지는 초기화 이외의 값 변경 금지이므로 제외 (C++에서 `const char *`)

---

# 좋은 코드의 일반적인 특징

+ 계약에 의한 디자인 (Design by Contract): 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약 후 계약을 어겼을 경우 명시적으로 왜 계셕할 수 없는지 예외 발생
  + Pros
    + 사전조건 혹은 사후조건 검증에서 실패하는 오류가 발생했을 때 오류를 쉽게 찾아낼 수 있음
    + 잘못된 가정 하에 코드의 핵심 부분이 실행되는 것을 방지
    + 책임의 한계를 명확히 할 수 있음
    + 장기적인 품질 보장
  + Cons
    + 애플리케이션의 핵심 논리뿐만 아니라 계약을 작성해야하므로 추가작업 발생
    + 계약에 대한 단위테스트 추가 가능성
  + 사전조건 (Precondition): 함수나 메서드가 제대로 동작하기 위해 보장해야하는 모든 것
  + 사후조건 (Postcondition): 메서드 또는 함수 반환값의 유효성을 검사하여 반환된 후의 상태를 강제하는 계약
+ 방어적 (Denfensive) 프로그래밍: 예상할 수 있는 시나리오의 오류를 처리하는 방법과 발생하지 않아야 하는 오류를 처리하는 방법
  + `except ${TYPE}Error`와 같이 사용 (비어있는 `except` 지양)
  + `traceback`의 노출 X
  + `assert`: 절대로 일어나지 않아야하는 상황
+ 관심사의 분리: 파급효과를 최소화하여 유지보수성 향상
  + 응집력 (Cohension): 객체가 작고 잘 정의된 목적을 가져야하며 가능한 작아야함
  + 결합력 (Coupling): 두 개 이상의 객체가 서로 어떻게 의존하는지를 나타내며 의존에 따른 종속성은 제한을 의미
+ 개발 지침 약어
  + DRY/OAOO
    + DRY: Do not Repeat Yourself
    + OAOO: Once And Only Once
  + YAGNI: You Ain't Gonna Need It
  + KIS: Keep It Simple
  + EAFP/LBYL
    + EAFP: Easier to Ask Forgiveness than Permission
    + LBYL: Look Before You Leap

---

# SOLID 원칙

+ 단일 책임 원칙 (Single Responsibility Principle, SRP): 소프트웨어 컴포넌트가 단 하나의 책임을 져야하는 원칙
  + 신 객체 (God Object): 필요 이상의 일을 하거나 너무 많은 것을 알고 있는 객체
+ 개방/폐쇄 원칙 (Open/Close Principle, OCP): 한 측면에서는 개방되어 있으면서도 다른 측면에서는 폐쇄되어야하는 원칙
+ 리스코프 치환 원칙 (Liskov Substitution Principle, LSP): 프로그램을 변경하지 않고 하위 타입의 객체로 치환이 가능해야하는 원칙
+ 인터페이스 분리 원칙 (Interface Segregation Principle, ISP): 다중 메서드를 가진 인터페이스가 있다면 더 적은 수의 메서드를 가진 여러 개의 메서드로 분할하는 원칙
  + 파이썬의 인터페이스: 추상 기본 클래스 개념 도입 (파이썬3)
+ 의존성 역전 원칙 (Dependency Inversion Principle, DIP): 코드가 세부 사항이나 구체적인 구현에 적응하도록 하지 않고 추상화된 객체에 적응하도록 하는 원칙

<!-- 6주차 -->

---

<!-- 7주차 -->

# 데코레이터를 사용한 코드 개선

> 데코레이터: 함수와 메서드의 기능을 쉽게 수정하기 위한 수단

+ 고차함수: 함수를 파라미터로 받아서 함수를 반환하는 함수

```python
def original(...):
    ...

original = modifier(original, ...)

@modifier             # 데코레이터
def original(...):    # 데코레이팅된 함수, 래핑된 객체
    ...
```

+ 함수 데코레이터

```python
class ControlledException(Exception):
    """도메인에서 발생하는 일반적인 예외"""


def retry(operation):
    @wraps(operation)
    def wrapped(*args, **kwargs):
        last_raised = None
        RETRIES_LIMIT = 3

        for _ in range(RETRIES_LIMIT):
            try:
                return operation(*args, **kwargs)
            except ControlledException as e:
                logger.info("retrying %s", operation.__qualname__)
                last_raised = e

        raise last_raised

    return wrapped

@retry
def run_operation(task):
    """실행 중 예외가 발생할 것으로 예상되는 특정 작업율 실행 """
    return task.run()
```

+ 클래스 데코레이터: 데코레이터 함수의 파라미터로 클래스를 받는 데코레이터
  + 장점
    + 코드 재사용과 DRY(Don't Repeat Yourself)원칙의 모든 이점을 공유함
    + 작고 간단한 클래스를 먼저 생성하고 추후 데코레이터로 기능을 보강할 수 있음
    + 특정 클래스에 대해서는 유지보수 시 데코레이터를 사용해 기존 로직을 쉽게 변경 가능 (메타 클래스를 사용하는 방법도 있으나 권장되진 않음)
  + 단점
    + 클래스가 점점 많아진다: 이벤트 클래스와 직렬화 클래스가 1:1로 매핑되어 있어 본질적 역할은 한 가지지만 점점 늘어나게 됨
    + 유연하지 않다: 코드의 재사용성 감소
    + 표준화 문제

```python
from datetime import datetime


def hide_field(field) -> str:
    return "**민감한 정보 삭제**"


def format_time(field_timestamp: datetime) -> str:
    return field_timestamp.strftime("%Y-%m-%d %H:%M")


def show_original(event_field):
    return event_field


class EventSerializer:
    def __init__(self, serialization_fields: dict) -> None:
        self.serialization_fields = serialization_fields

    def serialize(self, event) -> dict:
        return {
            field: transformation(getattr(event, field))
            for field, transformation in self.serialization_fields.items()
        }


class Serialization:
    def __init__(self, **transformations):
        self.serializer = EventSerializer(transformations)

    def __call__(self, event_class):
        def serialize_method(event_instance):
            return self.serializer.serialize(event_instance)

        event_class.serialize = serialize_method
        return event_class


@Serialization(
    username=show_original, password=hide_field, ip=show_original, timestamp=format_time
)
class LoginEvent:
    def __init__(self, username, password, ip, timestamp):
        self.username = username
        self.password = password
        self.ip = ip
        self.timestamp = timestamp
```

+ 파라미터를 가지는 데코레이터

```python
from functools import wraps

RETRIES_LIMIT = 3

def with_retry(retries_limit = RETRIES_LIMIT, allowed_exceptions = None):
    allowed_exceptions = allowed_exceptions or (ControlledException,)
    def retry(operation):
        @wraps(operation)
        def wrapped(*args, **kwargs):
            last_raised = None
            for _ in range(retries_limit):
                try:
                   return operation(*args, **kwargs)
                except allowed_exceptions as e:
                    logger.info("retrying %s due to %s ", operation, e)
                    last_raised = e
            raise last_raised

        return wrapped

    return retry


@with_retry()
def run_operation(task):
    return task.run()


@with_retry(retries_limit=5)
def run_with_custom_retries_limit(task):
    return task.run()


@with_retry(allowed_exceptions=(AttributeError,))
def run_with_custom_exceptions(task):
    return task.run()


@with_retry(retries_limit=4, allowed_exceptions=(ZeroDivisionError, AttributeError))
def run_with_custom_parameters(task):
    return task.run()
```

```python
class WithRetry:
    def __init__(self, retries_limit=RETRIES_LIMIT, allowed_exceptions=None):
        self.retries_limit = retries_limit
        self.allowed_exceptions = allowed_exceptions or (ControlledException,)

    def __call__(self, operation):
        @wraps(operation)
        def wrapped(*args, **kwargs):
            last_raised = None

            for _ in range(self.retries_limit):
                try:
                    return operation(*args, **kwargs)
                except self.allowed_exceptions as e:
                    logger.info("retrying %s due to %s", operation, e)
                    last_raised = e

            raise last_raised

        return wrapped


@WithRetry(retries_limit=5)
def run_with_custom_retries_limit(task):
    return task.run()
```

+ 데코레이터 용도
  + 코드 추적
    + 함수 경로 추적(stack trace)
    + 함수 지표 모니터링(CPU 사용률, 메모리 사용량)
    + 함수 실행시간 측정
    + 함수 호출 시점 및 파라미터 로깅
  + 파라미터 유효성 검사
  + 재시도 로직 구현
  + 일부 반복 작업을 데코레이터로 이동하여 클래스 단순화
+ 흔한 실수
  + 래핑된 함수 `return` 시 `@wraps`를 사용하지 않아 재정의 발생 가능
  + `@wraps` 밖에 정의된 코드들은 `import` 시 실행 가능
  + 메서드에서 데코레이터 사용 시 클래스로 정의된 데코레이터 사용 (`self`)
+ 데코레이터 작업 순서
  1. 처음부터 데코레이터를 만들지 않는다. 패턴이 생기고 데코레이터에 대한 추상화가 명확해지면 그 때 리팩토링을 한다.
  2. 데코레이터가 적어도 3회 이상 필요한 경우에만 구현한다.
  3. 데코레이터 코드를 최소한으로 유지한다.
+ 좋은 데코레이터의 특성
  + 캡슐화와 관심사의 분리: 좋은 데코레이터는 실제로 하는 일과 데코레이팅하는 일의 책임을 명확히 구분해야 한다. 어설프게 추상화 하면 안 된다. 즉, 데코레이터의 클라이언트는 내부에서 어떻게 구현했는지 전혀 알 수 없는 블랙박스 모드로 동작해야 한다.
  + 독립성: 데코레이터가 하는 일은 독립적이어야 하며 데코레이팅되는 객체와 최대한 분리되어야 한다.
  + 재사용성: 데코레이터는 하나의 함수 인스턴스에만 적용되는 것이 아니라 여러 유형에 적용 가능한 형태가 바람직하다. 왜냐하면 하나의 함수에만 적용된다면 데코레이터가 아니라 함수로 대신할 수도 있기 때문이다. 충분히 범용적이어야 한다.

---

# 디스크립터로 더 멋진 객체 만들기

---

# 제네레이터 사용하기

<!-- 7주차 -->

---

<!-- 8주차 -->

# 단위 테스트와 리팩토링

---

# 일반적인 디자인 패턴

---

# 클린 아키텍쳐

<!-- 8주차 -->
