> Index

- [소개, 코드 포매팅과 도구](#소개-코드-포매팅과-도구)
- [파이썬스러운 (Pythonic) 코드](#파이썬스러운-pythonic-코드)
- [좋은 코드의 일반적인 특징](#좋은-코드의-일반적인-특징)
- [SOLID 원칙](#solid-원칙)
- [데코레이터를 사용한 코드 개선](#데코레이터를-사용한-코드-개선)
- [디스크립터로 더 멋진 객체 만들기](#디스크립터로-더-멋진-객체-만들기)
- [제네레이터 사용하기](#제네레이터-사용하기)
- [단위 테스트와 리팩토링](#단위-테스트와-리팩토링)
- [일반적인 디자인 패턴](#일반적인-디자인-패턴)
- [클린 아키텍쳐](#클린-아키텍쳐)

---

<!-- 5주차 -->

# 소개, 코드 포매팅과 도구

+ [클린코드](https://hypers84.tistory.com/2460)란?
  1. 가독성: 이해하기 쉬운 용어 사용, 코드 작성 시 들여쓰기 기능 사용
  2. 단위성: 한 번에 한 가지 처리만 수행, 클래스 / 메서드 / 함수를 최소 단위로 분리
  3. 의존성: 영향도를 최소화, 코드의 변경이 다른 부분에 영향이 없게 작성
  4. 중복성: 중복된 코드를 제거, 공통된 코드를 사용
  5. 추상화: 클래스 / 메서드 / 함수에 대해 동일한 수준의 추상화 구현, 상세 내용은 하위 클래스 / 메서드 / 함수에서 구현
+ 코드 포매팅 == 클린코드?
  + 코드를 포매팅 하고 구조화하는 것은 클린코드의 최소요건
  + 코드 포매팅이 클린코드라는 명제는 **틀린 명제**
+ 코드를 잘 설명하는 방법
  1. 주석
     + Pros: 외부 라이브러리에 오류가 있는 경우
     + Cons: 코드에 포함되고 코드와 함께 업데이트가 되지 않을 수 있음
  2. 함수의 이름과 파라미터의 이름
  3. Docstring
     + `__doc__`을 통해 호출 가능
     + 설명 없이 코드만 보아도 직관적으로 이해가 되는 코드가 좋음
  4. Annotation
     + `__annotations__`를 통해 확인 가능
     + 동적 타입 언어의 특성은 바뀌지 않음

```python
>>> zerohertzLib.vision.grid.__doc__
'여러 image를 입력받아 한 정방형 image로 병합\n\n    Args:\n        imgs (``List[NDArray[np.uint8]]``): 입력 image\n        size: (``Optional[int]``): 출력 image의 크기\n        color: (``Optional[Tuple[int]]``): Padding의 색\n        file_name: (``Optional[str]``): 저장될 file의 이름\n\n    Returns:\n        ``None``: 현재 directory에 바로 image 저장\n\n    Examples:\n        >>> imgs = [cv2.resize(img, (random.randrange(300, 1000), random.randrange(300, 1000))) for _ in range(8)]\n        >>> imgs[2] = cv2.cvtColor(imgs[2], cv2.COLOR_BGR2GRAY)\n        >>> imgs[3] = cv2.cvtColor(imgs[3], cv2.COLOR_BGR2BGRA)\n        >>> zz.vision.grid(imgs)\n        >>> zz.vision.grid(imgs, color=(0, 255, 0))\n        >>> zz.vision.grid(imgs, color=(0, 0, 0, 0))\n\n        .. image:: _static/examples/dynamic/vision.grid.png\n            :align: center\n            :width: 600px\n    '
>>> zerohertzLib.vision.grid.__annotations__
{'imgs': typing.List[numpy.ndarray[typing.Any, numpy.dtype[numpy.uint8]]], 'size': typing.Union[int, NoneType], 'color': typing.Union[typing.Tuple[int], NoneType], 'file_name': typing.Union[str, NoneType], 'return': None}
```

<!-- 5주차 -->

---

<!-- 6주차 -->

# 파이썬스러운 (Pythonic) 코드

+ 인덱스와 슬라이스
  + 인덱싱: 음수를 사용한 배열의 끝 부터의 접근
  + 슬라이싱: 특정 구간의 요소 (`[::2]`)
+ 컨텍스트 관리자
  + 리소스 관리: `with`를 통한 리소스 해제
  + 구현: `__enter__`와 `__exit__` 메서드 사용 (또는 `contextlib.ContextDecorator`)
+ 프로퍼티, 속성과 객체 메서드의 다른 타입들
  + `getter`: `@property`
  + `setter`: `@${PROPERTY_NAME}.setter`
  + 명시적인 (암묵적인) private 정의는 가능하지만 파이썬의 모든 프로퍼티와 함수는 public
+ 이터러블 객체
  + 이터러블: `__iter__`
  + 이터레이터: `__next__`
+ 컨테이너 객체
  + `in` 연산 수행을 위해 `__contains__` 메서드를 구현
+ 객체의 동적 속성
  + `__getattr__` 메서드 정의를 통해 인스턴스의 멤버변수를 알아낼 수 있음
  + 정의 시 파이썬 내장 함수 `getattr`에도 영향
+ 호출형 객체
  + `__call__`을 통해 인스턴스를 함수와 같이 활용 가능
+ 파이썬의 지양점
  + 변경 가능한 파라미터 기본 값 (`[1, 2, 3]`, ...)
  + `str`은 선언과 동시에 이루어지는 초기화 이외의 값 변경 금지이므로 제외 (C++에서 `const char *`)

---

# 좋은 코드의 일반적인 특징

+ 계약에 의한 디자인 (Design by Contract): 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약 후 계약을 어겼을 경우 명시적으로 왜 계셕할 수 없는지 예외 발생
  + Pros
    + 사전조건 혹은 사후조건 검증에서 실패하는 오류가 발생했을 때 오류를 쉽게 찾아낼 수 있음
    + 잘못된 가정 하에 코드의 핵심 부분이 실행되는 것을 방지
    + 책임의 한계를 명확히 할 수 있음
    + 장기적인 품질 보장
  + Cons
    + 애플리케이션의 핵심 논리뿐만 아니라 계약을 작성해야하므로 추가작업 발생
    + 계약에 대한 단위테스트 추가 가능성
  + 사전조건 (Precondition): 함수나 메서드가 제대로 동작하기 위해 보장해야하는 모든 것
  + 사후조건 (Postcondition): 메서드 또는 함수 반환값의 유효성을 검사하여 반환된 후의 상태를 강제하는 계약
+ 방어적 (Denfensive) 프로그래밍: 예상할 수 있는 시나리오의 오류를 처리하는 방법과 발생하지 않아야 하는 오류를 처리하는 방법
  + `except ${TYPE}Error`와 같이 사용 (비어있는 `except` 지양)
  + `traceback`의 노출 X
  + `assert`: 절대로 일어나지 않아야하는 상황
+ 관심사의 분리: 파급효과를 최소화하여 유지보수성 향상
  + 응집력 (Cohension): 객체가 작고 잘 정의된 목적을 가져야하며 가능한 작아야함
  + 결합력 (Coupling): 두 개 이상의 객체가 서로 어떻게 의존하는지를 나타내며 의존에 따른 종속성은 제한을 의미
+ 개발 지침 약어
  + DRY/OAOO
    + DRY: Do not Repeat Yourself
    + OAOO: Once And Only Once
  + YAGNI: You Ain't Gonna Need It
  + KIS: Keep It Simple
  + EAFP/LBYL
    + EAFP: Easier to Ask Forgiveness than Permission
    + LBYL: Look Before You Leap

---

# SOLID 원칙

+ 단일 책임 원칙 (Single Responsibility Principle, SRP): 소프트웨어 컴포넌트가 단 하나의 책임을 져야하는 원칙
  + 신 객체 (God Object): 필요 이상의 일을 하거나 너무 많은 것을 알고 있는 객체
+ 개방/폐쇄 원칙 (Open/Close Principle, OCP): 한 측면에서는 개방되어 있으면서도 다른 측면에서는 폐쇄되어야하는 원칙
+ 리스코프 치환 원칙 (Liskov Substitution Principle, LSP): 프로그램을 변경하지 않고 하위 타입의 객체로 치환이 가능해야하는 원칙
+ 인터페이스 분리 원칙 (Interface Segregation Principle, ISP): 다중 메서드를 가진 인터페이스가 있다면 더 적은 수의 메서드를 가진 여러 개의 메서드로 분할하는 원칙
  + 파이썬의 인터페이스: 추상 기본 클래스 개념 도입 (파이썬3)
+ 의존성 역전 원칙 (Dependency Inversion Principle, DIP): 코드가 세부 사항이나 구체적인 구현에 적응하도록 하지 않고 추상화된 객체에 적응하도록 하는 원칙

<!-- 6주차 -->

---

<!-- 7주차 -->

# 데코레이터를 사용한 코드 개선

---

# 디스크립터로 더 멋진 객체 만들기

---

# 제네레이터 사용하기

<!-- 7주차 -->

---

<!-- 8주차 -->

# 단위 테스트와 리팩토링

---

# 일반적인 디자인 패턴

---

# 클린 아키텍쳐

<!-- 8주차 -->
